#!/usr/bin/env zsh

####################################################################################
###                                                                              ###
###                          NSFV check utility                                  ###
###                                                                              ###
###                             just for fun                                     ###
###                                                                              ###
####################################################################################

# Инициализируем переменные
KEY=`cat ~/.config/ncheck.key`
WORKDIR=$PWD
DESTDIR=''
INVERT=false
VERBOSE=false
PERMISSIVE=false
C_IS_SET=false # Приходится инициализировать их, даже если не нужны
M_IS_SET=false # Иначе условный оператор далее не работает
R_IS_SET=false

# Краткая подсказка по опциям
usage() {
    echo "Usage:"
    echo "  ncheck [-c DESTINATION ] [-i ] [ -k ] [ -l ] [ -m DESTINATION ] [ -p ] [-r ] [ -v ] [ DIRECTORY ] "
    echo "Description:"
    echo "No arguments : Just print filenames, like 'ls' does, but the utility will only show names of files with NSFW content"
    echo "If DIRECTORY is given, then perform check in it."    
    echo "-c DESTINATION : Copy files into DESTINATION. Incompatible with -r and -m."
    echo "-i : Invert the results. Show files without NSFW content."    
    echo "-k :  Reserved"
    echo "-l : Long, informative output. Print "score" of the content."
    echo "-m DESTINATION : Move files into the DESTINATION directory"
    echo "-p : Permissive mode. Allow 16+ erotic content. Use with caution."
    echo "-r : Remove files. No additional confirmations will be asked. Use with caution. Incompatible with -m and -c."
    echo "-u : Print this text, then exit"
    echo "-v : Print version and exit"
    exit -1
}

version() {
  echo "nCheck v. 0.1"
  exit -1
}

# Решил пренебречь наличием длинных опций типа --copy-to в пользу упрощения скрипта.
# Испольную встроенную команду getopts вместо внешней утилиты GNU getopt

while getopts c:iklm:pruv option
do
   case "${option}"  in  
                c) DESTDIR=${OPTARG} && C_IS_SET=true ;;
                i) INVERT=true && echo "Notice: option -i is under development now" ;;
                k) echo "Notice: option -k is under development now" ;;
                l) VERBOSE=true;;
                m) DESTDIR=${OPTARG} && M_IS_SET=true ;;
                p) PERMISSIVE=true;;
                r) echo "Notice: option -r is under development now" ;;
                u) usage ;;
                v) version ;;
                ?) echo "Invalid option: -$OPTARG" >&2 ;;
   esac
done

# Парочка проверок на совместимость опций
if [ $C_IS_SET = true ] && [ $M_IS_SET = true ] ; then
  echo "-c and -m options cannot be used at the same time! Exiting."
  exit 1
fi

if [ $C_IS_SET = true ] && [ $R_IS_SET = true ] ; then
  echo "-c and -r options cannot be used at the same time! Exiting."
  exit 1
fi

# Два условия, которые нужны для обработки имени директории, где будет прозводиться поиск файлов
# Если последний аргумент - директория, то если при этом не включены опции -m и -c, то это директория для поиска
if [ -d $argv[-1] ] && ! ( [ $C_IS_SET = true ] || [ $M_IS_SET = true ] ) ; then WORKDIR=$argv[-1] ; fi
# Возможен случай, когда включено -m или -c, но тогда предпоследним аргументом тоже должна быть директория
if [ -d $argv[-1] ] && ( [ $C_IS_SET = true ] || [ $M_IS_SET = true ] ) && [ -d $argv[-2] ] ; then WORKDIR=$argv[-1] ; fi
# Всё это нужно для синтаксиса типа ncheck -c /dir /searchdir

print() {
for FILENAME in `find $WORKDIR -maxdepth 1 -type f -exec file {} \; | grep -i 'image' | cut -d: -f1` ; do

  CURRENT_RESULT=`curl -s --request POST --url https://nsfw-images-detection-and-classification.p.rapidapi.com/adult-content-file \
    --header "X-RapidAPI-Host: nsfw-images-detection-and-classification.p.rapidapi.com"  \
    --header "X-RapidAPI-Key: $KEY" \
    -F "image=@$FILENAME"`
  
  FACTOR=`echo $CURRENT_RESULT | jq '.unsafe'`
  SCORE=`echo $CURRENT_RESULT | jq '.objects[0].score'`
  
# Просто выводим список файлов
if [[ $FACTOR == 'true' ]] ; then
  if [[ $VERBOSE == 'true' ]] ; then
    echo $FILENAME $SCORE
  else
    echo $FILENAME
  fi
fi

done
}

print
